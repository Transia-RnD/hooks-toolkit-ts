const ASSERT = (x) => {
  if (!x) {
    rollback(x.toString(), 0)
  }
}

const sto = [
  0x11, 0x00, 0x61, 0x22, 0x00, 0x00, 0x00, 0x00, 0x24, 0x04, 0x1f, 0x94, 0xd9,
  0x25, 0x04, 0x5e, 0x84, 0xb7, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x55, 0x13, 0x40,
  0xb3, 0x25, 0x86, 0x31, 0x96, 0xb5, 0x6f, 0x41, 0xf5, 0x89, 0xeb, 0x7d, 0x2f,
  0xd9, 0x4c, 0x0d, 0x7d, 0xb8, 0x0e, 0x4b, 0x2c, 0x67, 0xa7, 0x78, 0x2a, 0xd6,
  0xc2, 0xb0, 0x77, 0x50, 0x62, 0x40, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x79, 0x94,
  0x81, 0x14, 0x37, 0xdf, 0x44, 0x07, 0xe7, 0xaa, 0x07, 0xf1, 0xd5, 0xc9, 0x91,
  0xf2, 0xd3, 0x6f, 0x9e, 0xb8, 0xc7, 0x34, 0xaf, 0x6c,
]

const ins = [
  0x56, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
]

const ans = [
  0x11, 0x00, 0x61, 0x22, 0x00, 0x00, 0x00, 0x00, 0x24, 0x04, 0x1f, 0x94, 0xd9,
  0x25, 0x04, 0x5e, 0x84, 0xb7, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x55, 0x13, 0x40,
  0xb3, 0x25, 0x86, 0x31, 0x96, 0xb5, 0x6f, 0x41, 0xf5, 0x89, 0xeb, 0x7d, 0x2f,
  0xd9, 0x4c, 0x0d, 0x7d, 0xb8, 0x0e, 0x4b, 0x2c, 0x67, 0xa7, 0x78, 0x2a, 0xd6,
  0xc2, 0xb0, 0x77, 0x50, 0x56, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x62, 0x40,
  0x00, 0x00, 0x00, 0x00, 0xa4, 0x79, 0x94, 0x81, 0x14, 0x37, 0xdf, 0x44, 0x07,
  0xe7, 0xaa, 0x07, 0xf1, 0xd5, 0xc9, 0x91, 0xf2, 0xd3, 0x6f, 0x9e, 0xb8, 0xc7,
  0x34, 0xaf, 0x6c,
]

const ans2 = [
  0x11, 0x00, 0x61, 0x22, 0x00, 0x00, 0x00, 0x00, 0x24, 0x04, 0x1f, 0x94, 0xd9,
  0x25, 0x04, 0x5e, 0x84, 0xb7, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x54, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x55, 0x13, 0x40, 0xb3, 0x25, 0x86, 0x31, 0x96, 0xb5,
  0x6f, 0x41, 0xf5, 0x89, 0xeb, 0x7d, 0x2f, 0xd9, 0x4c, 0x0d, 0x7d, 0xb8, 0x0e,
  0x4b, 0x2c, 0x67, 0xa7, 0x78, 0x2a, 0xd6, 0xc2, 0xb0, 0x77, 0x50, 0x62, 0x40,
  0x00, 0x00, 0x00, 0x00, 0xa4, 0x79, 0x94, 0x81, 0x14, 0x37, 0xdf, 0x44, 0x07,
  0xe7, 0xaa, 0x07, 0xf1, 0xd5, 0xc9, 0x91, 0xf2, 0xd3, 0x6f, 0x9e, 0xb8, 0xc7,
  0x34, 0xaf, 0x6c,
]

const INVALID_ARGUMENT = -7
const TOO_SMALL = -4
const PARSE_ERROR = -18

const Hook = (arg) => {

  // Test field/sto undefined
  ASSERT(sto_emplace(undefined, 1, 1) == INVALID_ARGUMENT)
  ASSERT(sto_emplace(1, 1, undefined) == INVALID_ARGUMENT)

  // Test Field ID argument
  ASSERT(sto_emplace(1, 1, -1) == INVALID_ARGUMENT)
  ASSERT(sto_emplace(1, 1, 0xFFFFFFAF) == INVALID_ARGUMENT)

  // Test field argument
  ASSERT(sto_emplace(1, undefined, 1) == INVALID_ARGUMENT)
  ASSERT(sto_emplace(1, false, 1) == INVALID_ARGUMENT)

  ASSERT(sto_emplace([0x00, 0x01], [0x00, 0x01], 0x50006) == PARSE_ERROR)

  // Test size check
  {
    // src buffer too small
    ASSERT(sto_emplace([0x00], [0x00, 0x01], 0x50006) == TOO_SMALL)
    // // field buffer too small
    ASSERT(sto_emplace([0x00, 0x01], [0x00], 0x50006) == TOO_SMALL)
    // // field buffer too big
    // TO_BIG is not returned because the buffer is undefined when to large
    ASSERT(
      sto_emplace([0x00, 0x01], new Array(4097).fill(0x00), 0x50006) ==
        INVALID_ARGUMENT
    )
    // src buffer too big
    // TO_BIG is not returned because the buffer is undefined when to large
    ASSERT(
      sto_emplace(new Array(16385).fill(0x00), [0x00, 0x01], 0x50006) ==
        INVALID_ARGUMENT
    )
  }

  let buf = []

  // insert ledger index 561111111111111111111111111111111111111111111111111111111111111111

  {
    buf = sto_emplace(sto, ins, 0x50006)
    ASSERT(buf.length === sto.length + ins.length)

    for (let i = 0; i < ans.length; ++i) ASSERT(ans[i] == buf[i])

    // flip it to 54 and check it is installed before
    ins[0] = 0x54
    buf = sto_emplace(sto, ins, 0x50004)
    ASSERT(buf.length == sto.length + ins.length)
    for (let i = 0; i < ans2.length; ++i) ASSERT(ans2[i] == buf[i])
  }

  // test front insertion
  {
    const sto = [0x22, 0x00, 0x00, 0x00, 0x00]
    const ins = [0x11, 0x11, 0x11]

    const buf = sto_emplace(sto, ins, 0x10001)
    ASSERT(buf.length == sto.length + ins.length)
    const ans = [0x11, 0x11, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00]
    for (let i = 0; i < ans.length; ++i) ASSERT(ans[i] == buf[i])
  }

  // test back insertion
  {
    const sto = [0x22, 0x00, 0x00, 0x00, 0x00]
    const ins = [0x31, 0x11, 0x11, 0x11, 0x11, 0x12, 0x22, 0x22, 0x22]

    buf = sto_emplace(sto, ins, 0x30001)
    ASSERT(buf.length == sto.length + ins.length)
    const ans = [
      0x22, 0x00, 0x00, 0x00, 0x00, 0x31, 0x11, 0x11, 0x11, 0x11, 0x12, 0x22,
      0x22, 0x22,
    ]
    for (let i = 0; i < ans.length; ++i) ASSERT(ans[i] == buf[i])
  }
  // test replacement
  {
    const rep = [0x22, 0x10, 0x20, 0x30, 0x40]
    buf = sto_emplace(sto, rep, 0x20002)
    ASSERT(buf.length == sto.length)

    // check start
    ASSERT(buf[0] == sto[0] && buf[1] == sto[1] && buf[2] == sto[2])

    // check replaced part
    for (let i = 3; i < rep.length + 3; ++i) ASSERT(buf[i] == rep[i - 3])

    // check end
    for (let i = rep.length + 3; i < sto.length; ++i) ASSERT(sto[i] == buf[i])
  }

  return accept(0, 0)
}

export { Hook }
